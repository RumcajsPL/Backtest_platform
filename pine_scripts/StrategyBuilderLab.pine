//@version=6
strategy("ğŸ”¬Strategy Builder LabğŸ”¬", "ğŸ”¬SBLğŸ”¬", overlay=true,
   initial_capital=30000, currency=currency.USD, pyramiding = 0,
   default_qty_type=strategy.percent_of_equity, default_qty_value=5,
   commission_type=strategy.commission.percent, commission_value=0.01, process_orders_on_close=true)
// =============================================== FILTERING MANAGER BLOCK ===============================================
////////////////////////////////////////////////////////////////////////////////
// INPUT GROUPS & TOOLTIPS DEFINITIONS
////////////////////////////////////////////////////////////////////////////////
gS_title = "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ğŸ“ Source Triggers ğŸ“â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€" // Source Triggers
gS_tooltip = "ğŸ‘‰ Select the source from buil-in variable like: open, close etc.\n 
                  or select the source from external source\n 
                  like an indicator available on the same chart.\n
             ğŸ‘‰ Remark: buil-in input.source() is being used to catch external signals\n
                 Only plots: (plot(), plotchar(), plotshape() returning no negative value are captured. \n
             ğŸ‘‰ Up to 4 signals can be captured : 2 longs and 2 shorts" 

gF1_title = "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ã€½ï¸ Trend / Direction ã€½ï¸â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
gF1_tooltip = "ğŸ‘‰ Confirms market bias (bullish or bearish): \n" +
              "ğŸ”¹MACD â†’ trend + momentum combo \n" +
              "ğŸ”¹Moving Averages (MA) â†’ simple trend filter \n" +
              "ğŸ”¹VWAP â†’ session anchor, strong intraday bias \n" +
              "ğŸ”¹SuperTrend â†’ adaptive trend following \n" +
              "ğŸ‘‰ Pick ONE main bias filter:\n" +
              "ğŸ”¹MACD (Classic) â†’ EMA(12,26), Signal(9), confirm > 0 histogram \n" +
              "ğŸ”¹MACD (Slope) â†’ Histogram rising = bullish momentum \n" +
              "ğŸ”¹MACD (Strict) â†’ Both direction and slope must align \n" +
              "ğŸ”¹MA (Scalping) â†’ short MA(20) vs long MA(50) \n" +
              "ğŸ”¹MA (Intraday) â†’ MA(50) vs MA(200) \n" +
              "ğŸ”¹VWAP (Scalping) â†’ use Daily VWAP \n" +
              "ğŸ”¹VWAP (Intraday) â†’ Weekly VWAP \n" +
              "ğŸ”¹SuperTrend (Scalping) â†’ ATR(10), Mult=2.0 \n" +
              "ğŸ”¹SuperTrend (Intraday) â†’ ATR(14), Mult=3.0"

gF2_title = "â”€â”€â”€â”€â”€â”€â”€â”€â”€ğŸ”¥ Momentum / Regime Strength ğŸ”¥â”€â”€â”€â”€â”€â”€â”€â”€â”€"
gF2_tooltip = "ğŸ‘‰ Measures strength and velocity of the ongoing move:\n" +
              "ğŸ”¹Choppiness Index â†’ identifies range vs trend conditions\n" +
              "ğŸ”¹ADX â†’ measures trend strength (direction-agnostic)\n" +
              "ğŸ”¹ROC (Rate of Change) â†’ measures pure price acceleration or deceleration\n" +
              "   â–ª Positive = rising momentum\n" +
              "   â–ª Negative = falling momentum\n" +
              "   â–ª Strong impulses often precede continuation moves\n" +
              "ğŸ‘‰ Usage suggestions:\n" +
              "ğŸ”¹Choppiness (Scalping) â†’ < 55 = trending, > 60 = choppy\n" +
              "ğŸ”¹Choppiness (Intraday) â†’ < 50 = trending, > 60 = choppy\n" +
              "ğŸ”¹ADX (Scalping) â†’ ADX > 20 = valid trend\n" +
              "ğŸ”¹ADX (Intraday) â†’ ADX > 25 = valid trend\n" +
              "ğŸ”¹ROC (Scalping) â†’ Length 9â€“14, Threshold Â±0.2%â€“0.5%\n" +
              "ğŸ”¹ROC (Intraday) â†’ Length 14â€“21, Threshold Â±0.3%â€“0.8%"

gF3_title = "â”€â”€â”€â”€â”€â”€â”€â”€â”€â›½ Volume / ğŸ’¥ Volatility â”€â”€â”€â”€â”€â”€â”€â”€â”€"
gF3_tooltip = "ğŸ‘‰ Confirms market participation and volatility conditions:\n
              ğŸ”¹ATR-Normalized Volume â†’ compares current volume relative to volatility\n
              ğŸ”¹Bollinger Bands â†’ volatility expansion / contraction\n
              ğŸ”¹Keltner Channels â†’ directional volatility confirmation\n
             ğŸ‘‰ Recommended usage:\n
              ğŸ”¹Volume (Scalping) â†’ Volume/ATR > 1.2 Ã— MA(20) â‡’ strong participation\n
              ğŸ”¹Volume (Intraday) â†’ Volume/ATR > 1.5 Ã— MA(20)\n
              ğŸ”¹Bollinger (Scalping) â†’ Bandwidth rising â‡’ valid momentum\n
              ğŸ”¹Bollinger (Intraday) â†’ Look for squeeze (low width â†’ expansion)\n
              ğŸ”¹Keltner â†’ Price outside channel â‡’ trend continuation; inside â‡’ consolidation"

gF4_title = "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ã€°ï¸ Oscillators ã€°ï¸â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
gF4_tooltip = "ğŸ‘‰ Measures short-term momentum, overbought/oversold and cyclic price oscillations:\n" +
              "ğŸ”¹ RSI â†’ smooth, balanced oscillator, reacts slower\n" +
              "ğŸ”¹ DPO (Detrended Price Oscillator) â†’ removes long-term trend to highlight short-term price cycles\n" +
              "   â–ª Positive = price above its short-term mean (bullish bias)\n" +
              "   â–ª Negative = price below its short-term mean (bearish bias)\n" +
              "ğŸ”¹ CCI (Commodity Channel Index) â†’ measures deviation from typical price to identify strong impulses or reversals\n" +
              "   â–ª Above +100 = strong bullish momentum or overbought\n" +
              "   â–ª Below -100 = strong bearish momentum or oversold\n" +
              "ğŸ‘‰ Use depending on trading style:\n" +
              "ğŸ”¹ RSI (Scalping) â†’ OB > 70 / OS < 30\n" +
              "ğŸ”¹ RSI (Intraday) â†’ OB > 80 / OS < 20\n" +
              "ğŸ”¹ DPO (Scalping) â†’ Length 10â€“20, Threshold Â±0.1â€“0.2%\n" +
              "ğŸ”¹ DPO (Intraday) â†’ Length 20â€“30, Threshold Â±0.2â€“0.3%\n" +
              "ğŸ”¹ CCI (Scalping) â†’ Length 10â€“20, OB > +100 / OS < -100\n" +
              "ğŸ”¹ CCI (Intraday) â†’ Length 20â€“40, OB > +150 / OS < -150"

gF5_title = "â”€â”€â”€â”€â”€â”€â”€â”€â”€ğŸ§­ Market Structure & Flow ğŸ§­â”€â”€â”€â”€â”€â”€â”€â”€â”€"
gF5_tooltip = "ğŸ‘‰ Confirms the current structural flow of price:\n" +
             "ğŸ”¹Pivot Structure â†’ evaluates HH/HL vs LH/LL sequences.\n" +
             "ğŸ”¹Local Angle (Slope) â†’ measures short-term direction bias.\n" +
             "ğŸ‘‰ Typically used to confirm breakout or early trend phases.\n" +
             "ğŸ‘‰ Recommended usage:\n" +
             "ğŸ”¹Pivot Structure (Scalping) â†’ Zig-Zag Reversal â†’ 0.2% \n" +
             "   â–ª HH/HL = bullish bias for longs\n" +
             "   â–ª LH/LL = bearish bias for shorts\n" +
             "ğŸ”¹Pivot Structure (Intraday) â†’ Zig-Zag Reversal â†’ 0.5% \n" +
             "   â–ª Percent Lower = more sensitive (more swing updates, possible whipsaws)\n" +
             "    â–ª Higher = less sensitive \n" +
             "ğŸ”¹Local Angle (Scalping) â†’ Lookback 5â€“10, Min Angle 0.1â€“0.25 rad\n" +
             "   â–ª Steeper angles = stronger momentum\n" +
             "   â–ª Shorter lookback = faster response\n" +
             "ğŸ”¹Local Angle (Intraday) â†’ Lookback 10â€“20, Min Angle 0.08â€“0.15 rad\n" +
             "   â–ª Gentle slopes = sustainable trends\n" +
             "   â–ª Longer lookback = smoother signals\n\n" +
             "ğŸ‘‰ Pro Tips:\n" +
             "ğŸ”¹ Combine both filters for high-probability entries\n" +
             "ğŸ”¹Pivot + Angle alignment = strongest signals\n" +
             "ğŸ”¹ Use in trending markets for best results\n" +
             "ğŸ”¹ Avoid during choppy/range-bound conditions"

gT_title = "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ğŸ• Time Frame Bias ğŸ•â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
gT_tooltip = "ğŸ‘‰ Higher Time Frame (HTF) Bias applied only on MACD, MA and Pivot filters.\n" +
              "ğŸ”¹The timeframe used for HTF filter checks. \n" + 
              "ğŸ”¹Use 'chart' (default) to disable HTF bias and use the current chart's timeframe."

///////////////////////////////////////////////////////////////////////
// INPUTS SOURCES & FILTERS
////////////////////////////////////////////////////////////////////////////////
// Source Triggers
longSrc1       = input.source(close, "ğŸŸ¢ Primary Long", group = gS_title, inline = "primary", tooltip = gS_tooltip)
shortSrc1      = input.source(close, "ğŸ”´ Primary Short", group = gS_title, inline = "primary")
longSrc2       = input.source(close, "ğŸŸ¢ Secondary Long", group = gS_title, inline = "secondary", tooltip = gS_tooltip)
shortSrc2      = input.source(close, "ğŸ”´ Secondary Short", group = gS_title, inline = "secondary")

// Higher Time Frame Bias
htfTimeframe = input.timeframe(title="ğŸ• Time Frame bias (leave 'Chart' if want disabled)", defval="", group=gT_title, tooltip = gT_tooltip)
// MACD + MACD Histogram Slope
useMACD     = input.bool(false, "ã€½ï¸ Enable MACD", group=gF1_title, inline="macd1", tooltip=gF1_tooltip)
macdMode    = input.string("Classic", "MACD Mode", options=["Classic", "Histogram Slope", "Strict (Both)"], 
                 group=gF1_title, inline="macd1", tooltip="Classic = direction only\nHistogram Slope = momentum acceleration\nStrict = both direction & momentum must align.")
macdFastLen  = input.int(12, "ğŸ“ Fast EMA", group=gF1_title, inline="macd2", minval=2)
macdSlowLen  = input.int(26, "ğŸ“ Slow EMA", group=gF1_title, inline="macd2", minval=3)
macdSignalLen = input.int(9, "ğŸ“ Signal EMA", group=gF1_title, inline="macd3", minval=2)
macdSlopeLen = input.int(3, "ğŸ“ Slope Lookback", group=gF1_title, inline="macd3",
                 tooltip="Bars back for histogram slope comparison (used in Slope and Strict modes).",minval=1)

// MAs
useMA         = input.bool(false, "ã€½ï¸ Enable MA Filter", group=gF1_title, inline = "maIN1", tooltip=gF1_tooltip)
maType        = input.string("EMA","MA Type", options=["SMA","EMA","WMA","HMA"], group=gF1_title, inline = "maIN1")
maLen         = input.int(25, "ğŸ“ MA Length", group=gF1_title, inline = "maIN2", minval = 1)
maSlopeLen    = input.int(10, "ğŸ“ Slope Lookback", group=gF1_title, inline = "maIN2", tooltip="ğŸ‘‰ Length for moving average calculation. Longer for thend confirmation\n
                                                                                                 ğŸ‘‰ Number of bars back to check for the MA's slope. A higher number confirms a more stable trend.", minval = 1)

// VWAP
useVWAP       = input.bool(false, "ã€½ï¸ Enable VWAP Filter", group=gF1_title, inline = "vwapIN1", tooltip=gF1_tooltip)
vwapBuffer    = input.float(0.0, "â­ VWAP Buffer (%)", minval = 0, step=0.001, group=gF1_title, inline = "vwapIN1", tooltip="ğŸ‘‰ Lookback for slope direction. Set =1 to disable slope check\n
                                                                                                                         ğŸ‘‰ Require price to be at least X% above/below VWAP. Set 0 to disable buffer")

// Super Trend
useSUPT         = input.bool(false, "ã€½ï¸ Enable Supertrend Filter", group=gF1_title, inline = "suptIN1", tooltip=gF1_tooltip)
suptAtrLen      = input.int(10,    "ğŸ“ ATR Length", group=gF1_title, inline = "suptIN2", minval = 1)
suptFactor      = input.float(3, "â­ Factor",  step = 0.1, group=gF1_title, inline = "suptIN2", tooltip="ğŸ‘‰ ATR length for Supertrend calculation\n
                                                                                                         ğŸ‘‰ ATR multiplier for Supertrend calculation", minval = 1)

// Choppiness Index
useChop       = input.bool(false, "ğŸ”¥ Enable Choppiness", group=gF2_title, inline = "chopIN1", tooltip=gF2_tooltip)
ciLen         = input.int(14,    "ğŸ“ Length", group=gF2_title, inline = "chopIN2", minval = 1)
chopThr       = input.float(61.8,"â­ Threshold", step = 0.1, group=gF2_title, inline = "chopIN2" , tooltip="ğŸ‘‰ Length for Choppiness Index calculation\n
                                                                                                                     ğŸ‘‰ Threshold below which market is considered trending", minval = 1)

// ADX
useADX        = input.bool(false, "ğŸ”¥ Enable ADX Filter", group=gF2_title, inline = "adxIN1", tooltip=gF2_tooltip)
adxLen        = input.int(14,    "ğŸ“ ADX Length", group=gF2_title, inline = "adxIN1", minval = 1)
adxThr        = input.float(18.0,"â­ ADX Threshold",  step = 0.2, group=gF2_title, inline = "adxIN2", tooltip="", minval = 1)
diLen         = input.int(10,    "ğŸ“ DI Length", group=gF2_title, inline = "adxIN2", tooltip="ğŸ‘‰ Threshold above which trend is considered strong\n
                                                                                             ğŸ‘‰ Length for Directional Indicators (+DI and -DI)", minval = 1)

// ROC (Rate of Change)
useROC      = input.bool(false, "ğŸ”¥ Enable ROC", group = gF2_title, tooltip = gF2_tooltip, inline = "rocIN1")
rocLen      = input.int(14, "ğŸ“ ROC Length", group = gF2_title, inline = "rocIN1", minval = 2, maxval = 100)
rocThreshold= input.float(0.1, "â­ Threshold (%)", group = gF2_title, inline = "rocIN2", 
                             tooltip = "ROC = (Close - Close[n]) / Close[n] * 100\n" +
                                      "â–ª Positive ROC = upward acceleration\n" +
                                      "â–ª Negative ROC = downward acceleration\n" +
                                      "â–ª Threshold defines minimum impulse strength\n" +
                                      "Suggested:\n" +
                                      "Scalping â†’ 0.2â€“0.5%\n" +
                                      "Intraday â†’ 0.3â€“0.8%", 
                             step = 0.01, minval = 0.01, maxval = 2.0)

// Volume
useVol       = input.bool(false, "â›½ Volume", group = gF3_title, tooltip = gF3_tooltip, inline = "vol1")
volMaLen     = input.int(20, "ğŸ“ MA Length", group = gF3_title, inline = "vol1", minval = 5, maxval = 100)
atrLenVol    = input.int(14, "ğŸ“ ATR Length", group = gF3_title, inline = "vol2", tooltip = "ATR is used to normalize volume, allowing comparison across assets with different price scales.")

// Volatility - Bollinger Bands
useBBW        = input.bool(false, "ğŸ’¥ Enable BB Width", group=gF3_title, inline = "bbIN1", tooltip=gF3_tooltip) 
bbLen         = input.int(14, "ğŸ“ BB Length", group=gF3_title, inline = "bbIN1", minval = 1)
bbwMaLen      = input.int(30,    "ğŸ“ BBW MA Length", group=gF3_title, inline = "bbIN2", tooltip="", minval = 1)
bbwFilterMult = input.float(0.5, "â­ Filter Multiplier", step = 0.02, group=gF3_title, inline = "bbIN2", tooltip="ğŸ‘‰ Length for Bollinger Band Width moving average\n
                                 ğŸ‘‰ Filters for volatility expansion. A value of 1.1 requires the current BB width to be at least 10% greater than its moving average.", minval = 0.02)

// Volatility - Keltner Channels
useKC          = input.bool(false, "ğŸ’¥ Enable Keltner", group = gF3_title, tooltip = gF3_tooltip, inline = "kcIN1")
kcLen          = input.int(20, "ğŸ“ KC EMA Length", group = gF3_title, inline = "kcIN1", minval = 2, maxval = 100)
kcMult         = input.float(1.5, "â­ ATR Multiplier", group = gF3_title, inline = "kcIN2", step = 0.1, minval = 0.1, maxval = 5.0,
                               tooltip = "Keltner Channels = EMA Â± (ATR Ã— Multiplier)\n" +
                                         "â–ª Lower values = tighter channel (sensitive)\n" +
                                         "â–ª Higher values = wider channel (conservative)\n" +
                                         "Typical:\n" +
                                         "Scalping â†’ 1.2â€“1.8\n" +
                                         "Intraday â†’ 1.5â€“2.5")
kcATRlen       = input.int(10, "ğŸ“ ATR Length", group = gF3_title, inline = "kcIN2", minval = 2, maxval = 100)

// RSI
useRSI        = input.bool(false, "ã€°ï¸ Enable RSI", group = gF4_title, tooltip = gF4_tooltip, inline = "rsiIN1")
rsiLen        = input.int(14, "ğŸ“ RSI Length", group = gF4_title, inline = "rsiIN1", minval = 2, maxval = 50)
rsiOverbought = input.int(70, "ğŸ”´ Overbought", group = gF4_title, inline = "rsiIN2", minval = 50, maxval = 95)
rsiOversold   = input.int(30, "ğŸŸ¢ Oversold", group = gF4_title, inline = "rsiIN2", tooltip="RSI Overbought ğŸ‘‰ level above which market is considered overbought \n
                                                                                             RSI Oversold ğŸ‘‰ level below which market is considered oversold", minval = 5, maxval = 50)

// DPO
useDPO      = input.bool(false, "ã€°ï¸ Enable DPO", group = gF4_title, tooltip = gF4_tooltip, inline = "dpoIN1")
dpoLen      = input.int(20, "ğŸ“ DPO Length", group = gF4_title, inline = "dpoIN1", minval = 3, maxval = 100, 
                         tooltip = "Length of the centered moving average used to detrend the price.\nShorter â†’ faster response, more noise.\nLonger â†’ smoother cycles, more lag.")
dpoSmooth   = input.int(3, "â­ Smoothing", group = gF4_title, inline = "dpoIN2", minval = 1, 
                         tooltip = "Optional smoothing period for DPO output. Helps stabilize spikes without delaying signals.")
dpoThresh   = input.float(0.2, "â­ Threshold (%)", group = gF4_title, inline = "dpoIN2", step = 0.01, minval = 0.01, maxval = 1.0, 
                         tooltip = "Defines neutral zone around zero (in % of price).\nHigher value = stricter filtering, fewer signals.")

// CCI (Commodity Channel Index)
useCCI        = input.bool(false, "ã€°ï¸ Enable CCI", group = gF4_title, tooltip = gF4_tooltip, inline = "cciIN1")
cciLen        = input.int(20, "ğŸ“ CCI Length", group = gF4_title, inline = "cciIN1", minval = 3, maxval = 100)
cciOverbought = input.int(100, "ğŸ”´ Overbought", group = gF4_title, inline = "cciIN2", minval = 50, maxval = 300)
cciOversold   = input.int(-100, "ğŸŸ¢ Oversold", group = gF4_title, inline = "cciIN2", tooltip = 
                                                                                         "CCI Overbought/Oversold levels:\n" +
                                                                                         "â–ª Above OB = strong upward momentum or potential exhaustion\n" +
                                                                                         "â–ª Below OS = strong downward momentum or potential reversal", 
                                                                                     minval = -300, maxval = -50)

// Pivot
useStructurePivot = input.bool(false, 
     title = "ğŸ§­ Use Pivot Structure", 
     tooltip = "Detects structural bias using real-time swing sequences (HH/HL vs LH/LL).\n" +
               "Updated every bar without waiting for pivot confirmation.",
     group = gF5_title, inline="pivot1")

zzPercent = input.float(0.2, "â­ Zig-Zag Reversal (%)", 
     tooltip = "Minimum reversal % to form new zig-zag leg.\n" +
               "Lower = more sensitive (more swing updates, possible whipsaws)\n" +
               "Higher = less sensitive (cleaner swings, more lag)\n\n" +
               "Recommended settings:\n" +
               "â€¢ 1-min chart: 0.15-0.30%\n" +
               "â€¢ 5-min chart: 0.20-0.40%\n" +
               "â€¢ 15-min chart: 0.30-0.60%\n" +
               "â€¢ 1-hour chart: 0.50-1.00%",
     step = 0.01, minval = 0.01, maxval = 3.0, group = gF5_title, inline="pivot1")

// Local angle
useStructureAngle = input.bool(false, 
     title = "ğŸ§­ Use Local Angle", 
     tooltip = "Measures the local trend slope via linear regression angle.",
     group = gF5_title, inline="angle1")
angleLen  = input.int(10, "ğŸ“ Lookback", minval = 2, group = gF5_title, inline="angle1")
minAngle  = input.float(0.15, "ğŸ“ Min Angle (rad)", step = 0.01, group = gF5_title, inline="angle2")
////////////////////////////////////////////////////////////////////////////////
// FILTER CALCULATIONS / HELPER FUNCTIONS
////////////////////////////////////////////////////////////////////////////////
// Helper function to determine effective timeframe
getEffectiveTimeframe() =>
    htfTimeframe == "" ? timeframe.period : htfTimeframe

effectiveTF = getEffectiveTimeframe()
// MACD
macdFast   = ta.ema(close, macdFastLen)
macdSlow   = ta.ema(close, macdSlowLen)
macd       = macdFast - macdSlow
macdSignal = ta.ema(macd, macdSignalLen)
macdHist   = macd - macdSignal
[htfMACD, htfSignal, htfHist] = request.security(syminfo.tickerid, effectiveTF, 
     [macd, macdSignal, macdHist], 
     lookahead=barmerge.lookahead_off)
htfHistDelta = htfHist - htfHist[macdSlopeLen]
htfHistNorm  = htfHistDelta / ta.stdev(htfHist, 50)
getMACDFilter(isLong) =>
    if not useMACD
        true
    else
        // Use HTF values for direction and slope
        dirOK   = isLong ? htfHist > 0 : htfHist < 0
        slopeOK = isLong ? htfHistNorm > 0 : htfHistNorm < 0

        if macdMode == "Classic"
            dirOK
        else if macdMode == "Histogram Slope"
            slopeOK
        else  // "Strict (Both)"
            dirOK and slopeOK
// MAs
ma = switch maType
    "SMA" => ta.sma(close, maLen)
    "EMA" => ta.ema(close, maLen)
    "WMA" => ta.wma(close, maLen)
    "HMA" => ta.hma(close, maLen)
htfMA = request.security(syminfo.tickerid, effectiveTF, ma, 
     lookahead=barmerge.lookahead_off)
getMAFilter(isLong) =>
    if not useMA
        true
    else
        // Compare HTF MA with its value maSlopeLen bars ago on HTF
        isLong ? htfMA > htfMA[maSlopeLen] : htfMA < htfMA[maSlopeLen]     
// VWAP
vwap = ta.vwap
aboveVWAP = close > vwap * (1 + vwapBuffer/100)
belowVWAP = close < vwap * (1 - vwapBuffer/100)
getVWAPFilter(isLong) =>
    if not useVWAP
        true
    else
        isLong ? aboveVWAP : belowVWAP
// Supertrend
[stUp, stDn] = ta.supertrend(suptFactor, suptAtrLen)
getSuptFilter(isLong) =>
    if not useSUPT
        true
    else
        isLong ? close > stDn : close < stUp
// Choppiness
highLowDiff = ta.highest(ciLen) - ta.lowest(ciLen)
ci = highLowDiff > 0 ? 100 * math.log10(math.sum(ta.atr(1), ciLen) / highLowDiff) / math.log10(ciLen) : 100
getChopFilter() =>
    not useChop or ci < chopThr
// ADX
[_, _, adxVal] = ta.dmi(diLen, adxLen)
getADXFilter() =>
    not useADX or adxVal > adxThr
// ROC (Rate of Change)
roc = ((close - close[rocLen]) / close[rocLen]) * 100
getROCFilter(isLong) =>
    if not useROC
        true
    else
        isLong ? roc > rocThreshold : roc < -rocThreshold
// Volume
atrVol       = ta.atr(atrLenVol)
volNorm = volume / math.max(atrVol, 1e-10)
volNormMA    = ta.sma(volNorm, volMaLen)
getVolFilter() =>
    if not useVol
        true
    else
        volNorm > volNormMA

// BBW - Calculate always
bbw = ta.bbw(close, bbLen, 2)
bbwMA = ta.sma(bbw, bbwMaLen)
getBBWFilter() =>
    not useBBW or bbw > (bbwMA * bbwFilterMult)
// KELTNER CHANNELS
kcBasis = ta.ema(close, kcLen)
kcATR   = ta.atr(kcATRlen)
kcUpper = kcBasis + kcATR * kcMult
kcLower = kcBasis - kcATR * kcMult
getKCFilter(isLong) =>
    if not useKC
        true
    else
        isLong ? close < kcUpper : close > kcLower
// RSI
rsi = ta.rsi(close, rsiLen)
getRSIFilter(isLong) =>
    if not useRSI
        true
    else
        isLong ? rsi < rsiOverbought : rsi > rsiOversold
// DPO
lookback = math.floor(dpoLen / 2) + 1
dpo_raw     = close - ta.sma(close, dpoLen)
dpo         = ta.sma(dpo_raw, dpoSmooth) // smoothed DPO
dpo_norm    = dpo / close * 100           // normalize as % deviation from price
getDPOFilter(isLong) =>
    if not useDPO
        true
    else
        isLong ? dpo_norm < 0 and dpo_norm > -dpoThresh : 
                 dpo_norm > 0 and dpo_norm < dpoThresh
// CCI (Commodity Channel Index)
cci = ta.cci(close, cciLen)
getCCIFilter(isLong) =>
    if not useCCI
        true
    else
        isLong ? cci < cciOverbought : cci > cciOversold
// Pivot
var float zzHigh = high
var float zzLow = low
var float zzLastHigh = 0.0
var float zzLastLow = 0.0
var int zzTrend = 0  // Current zig-zag direction
var int zzBias = 0   // Structure bias
zzThreshold = close * (zzPercent / 100)
if bar_index == 0
    zzTrend := 1
    zzHigh := high
    zzLow := low
if zzTrend == 1  // Currently in uptrend
    if high > zzHigh
        zzHigh := high  // Update current leg high
    else if low < zzHigh - zzThreshold
        // Reversal down detected
        zzLastHigh := zzHigh
        zzLow := low
        zzTrend := -1
        if zzLow > zzLastLow and zzLastLow > 0
            zzBias := 1  // HH + HL = bullish
        else if zzLow < zzLastLow and zzLastLow > 0
            zzBias := -1  // HH + LL = bearish
        else
            zzBias := 0
else  // Currently in downtrend
    if low < zzLow
        zzLow := low  // Update current leg low
    else if high > zzLow + zzThreshold
        // Reversal up detected
        zzLastLow := zzLow
        zzHigh := high
        zzTrend := 1
        if zzHigh > zzLastHigh and zzLastHigh > 0
            zzBias := 1  // HH + HL = bullish
        else if zzHigh < zzLastHigh and zzLastHigh > 0
            zzBias := -1  // LH + LL = bearish
        else
            zzBias := 0
[htfPivotBias, htfPivotTrend] = request.security(syminfo.tickerid, effectiveTF, 
     [zzBias, zzTrend], lookahead=barmerge.lookahead_off)

// Use HTF pivot values in filter
getPivotStructureFilter(bool isLong) =>
    if not useStructurePivot
        true
    else
        isLong ? htfPivotBias == 1 : htfPivotBias == -1
// Local Angle
angleSlope = ta.linreg(close, angleLen, 0)
angleDelta = angleSlope - angleSlope[angleLen]
angleNorm = angleDelta / math.max(ta.stdev(close, angleLen), close * 0.0001)
currentAngle = math.atan(angleNorm)
angleLongCond = currentAngle > minAngle
angleShortCond = currentAngle < -minAngle
getAngleStructureFilter(bool isLong) =>
    if not useStructureAngle
        true
    else
        isLong ? angleLongCond : angleShortCond
////////////////////////////////////////////////////////////////////////////////
// FILTER MANAGEMENT 
////////////////////////////////////////////////////////////////////////////////
filter_long = getMACDFilter(true) and
              getMAFilter(true) and 
              getVWAPFilter(true) and
              getSuptFilter(true) and
              getChopFilter() and 
              getADXFilter() and
              getROCFilter(true) and
              getVolFilter() and 
              getBBWFilter() and
              getKCFilter(true) and
              getRSIFilter(true) and
              getDPOFilter(true) and
              getCCIFilter(true) and
              getPivotStructureFilter(true) and
              getAngleStructureFilter(true)
filter_short = getMACDFilter(false) and
               getMAFilter(false) and 
               getVWAPFilter(false) and
               getSuptFilter(false) and
               getChopFilter() and 
               getADXFilter() and 
               getROCFilter(false) and
               getVolFilter() and 
               getBBWFilter() and
               getKCFilter(false) and
               getRSIFilter(false) and
               getDPOFilter(false) and
               getCCIFilter(false) and
               getPivotStructureFilter(false) and
               getAngleStructureFilter(false)
////////////////////////////////////////////////////////////////////////////////
// SIGNALS GENERATOR
////////////////////////////////////////////////////////////////////////////////
getLongCondition() =>
     (longSrc1 > 0 and longSrc1[1] == 0) or (longSrc2 > 0 and longSrc2[1] == 0)
getShortCondition() =>
     (shortSrc1 > 0 and shortSrc1[1] == 0) or (shortSrc2 > 0 and shortSrc2[1] == 0)
// Final signals
longCondition  = getLongCondition() and filter_long
shortCondition = getShortCondition() and filter_short
// =============================================== END OF: FILTERING MANAGER BLOCK ===============================================

// =============================================== TRADING MANAGER BLOCK ===============================================
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INPUT PARAMETERS - TRADING SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Trading Groups Definitions
gTime_title = "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ğŸ• Trading Session ğŸ•â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
gTime_tooltip = "ğŸ‘‰ Define your active trading hours to avoid trading during low liquidity or overnight sessions\n" +
               "ğŸ”¹ Enable/Disable time filtering completely\n" +
               "ğŸ”¹ Set your local timezone for accurate session timing\n" +
               "ğŸ”¹ Define start and end times for your trading day\n\n" +
               "ğŸ‘‰ Pro Tips:\n" +
               "â–ª European Session: 8:00-17:00 CET\n" +
               "â–ª US Session: 14:30-21:00 EST\n" +
               "â–ª Asian Session: 23:00-08:00 GMT"

gSLTP_title = "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€âš–ï¸ Risk Management âš–ï¸â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
gSLTP_tooltip = "ğŸ‘‰ Configure your stop-loss and take-profit strategy\n" +
               "ğŸ”¹ ATR-based dynamic stops that adapt to market volatility\n" +
               "ğŸ”¹ Fixed risk-reward ratios for consistent position sizing\n" +
               "ğŸ”¹ Separate multipliers for SL and TP calculations\n" +
               "ğŸ‘‰ Recommended Settings:\n" +
               "â–ª Scalping: SL 1.0-1.5 ATR, TP 2.0-3.0 ATR\n" +
               "â–ª Day Trading: SL 1.5-2.0 ATR, TP 2.5-4.0 ATR\n" +
               "â–ª Swing Trading: SL 2.0-3.0 ATR, TP 3.0-5.0 ATR"

gRisk_title = "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ğŸ’° Risk Control ğŸ’°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
gRisk_tooltip = "ğŸ‘‰ Risk management based on annual price ranged percentile\n" +
               "ğŸ”¹ Max Percentile - prevents from excessive risk\n" +
               "ğŸ”¹ Uses 12-month high/low range as reference (0-1 scale)\n" +
               "ğŸ”¹ Allow Exceed Limit - controls behavior when stop loss exceeds defined max percentile\n\n" +
               "ğŸ‘‰ How it works:\n" +
               "â–ª 1.0 = Feature disabled (100% of risk accepted)\n" +
               "â–ª 0.05 = Maximum 5% of risk is defined\n" +
               "â–ª Lower values = tighter risk control\n\n" +
               "ğŸ‘‰ Allow Exceed Limit:\n" +
               "â–ª TRUE: Trade continues with SL adjusted to max percentile\n" +
               "â–ª FALSE: Trade is refused if SL exceeds max percentile"

// Time Filtering
useTimeFilter = input.bool(true, "ğŸ• Enable Time Filter", group=gTime_title, inline="tz1", tooltip=gTime_tooltip)
timezone_manual = input.string("Europe/Paris", "ğŸŒ Timezone", 
     options=["UTC", "America/New_York", "Europe/London", "Europe/Paris", "Asia/Tokyo", "America/Chicago"], 
     group=gTime_title, inline="tz1", tooltip="Select your local timezone for accurate session timing")
start_hour = input.int(8, "ğŸ•— From: Hour", minval=0, maxval=23, group=gTime_title, inline = "start1")
start_minute = input.int(30, "Minutes", minval=0, maxval=59, group=gTime_title, inline = "start1")
end_hour = input.int(20, "ğŸ•— To: Hour", minval=0, maxval=23, group=gTime_title, inline = "end1")
end_minute = input.int(30, "Minutes", minval=0, maxval=59, group=gTime_title, inline = "end1")
// Opposite Signal Control
allowOppositeClose = input.bool(false, "âš–ï¸ Close on Opposite Signal", group=gSLTP_title,
     tooltip="When enabled: Opposite signals will close current position and reverse\n" +
             "When disabled: Opposite signals are ignored until position closes via SL/TP")
// SL/TP Settings
useSL         = input.bool(true,  "âš–ï¸ Enable SL/TP", group=gSLTP_title, inline="sltp1", tooltip=gSLTP_tooltip)
atrLen        = input.int(14,     "ğŸ“ ATR Length", minval = 1, group=gSLTP_title, inline="sltp1")
slMult        = input.float(1.4,  "â­ SL Multiplier", step = 0.1, minval = 1, group=gSLTP_title, inline="sltp2")
tpMult        = input.float(2.8,  "â­ TP Multiplier", step = 0.1, minval = 1, group=gSLTP_title, inline="sltp2")
// Annual Range Normalized Risk Management
allowTradeOnLimit = input.bool(false, "âš ï¸ Allow Exceed Limit", group=gRisk_title, inline="risk1",
                         tooltip="When enabled: If ATR stop exceeds max percentile, trade continues with adjusted SL\n" +
                         "When disabled: Trade is cancelled if stop exceeds max risk percentile")
maxPercentile = input.float(1.0, "ğŸ”’ Max Risk Percentile", minval=0.0001, maxval=1.0, step=0.0001, 
     group=gRisk_title, inline="risk1", tooltip="Maximum stop loss as % of annual range (0-1 scale)\n" +
                                               "1.0 = disabled (100% risk accepted)\n" +
                                               "0.05 = 5% of annual range\n" +
                                               "Lower values = tighter risk control")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ANNUAL RANGE CALCULATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Annual Range Variables
var float annualHigh = na
var float annualLow = na
var float annualRange = na

// Fetch annual high/low from monthly timeframe (calculated once on script load)
if na(annualRange)
    // Fetch the 1-Year (12-month) High/Low from the "1M" timeframe.
    // We use [1] to get the completed, non-repainting range.
    // 'lookahead=barmerge.lookahead_on' ensures we get the same value for all bars.
    [_high, _low] = request.security(syminfo.tickerid, "1M", 
         [ta.highest(high, 12)[1], ta.lowest(low, 12)[1]], 
         lookahead=barmerge.lookahead_on)
    annualHigh := _high
    annualLow := _low
    annualRange := annualHigh - annualLow

// Normalizes a distance value against the annual range (0-1 scale).
// @param distance The price distance to normalize (e.g., stop loss distance).
// @param priceRange The total range to normalize against (annualRange).
// @return The normalized ratio (e.g., 0.05 = 5% of annual range). Returns 0 if range is 0.
f_normalize_distance(float distance, float priceRange) =>
    priceRange > 0 ? math.abs(distance) / priceRange : 0.0

// Convert percentile to actual price distance
// @param entryPrice The entry price for the trade
// @param riskPercentile The risk as a percentage of annual range (0-1)
// @param isLong True for long position, false for short
// @return The stop loss price at the max percentile level
f_percentile_to_price(float entryPrice, float riskPercentile, bool isLong) =>
    priceDistance = riskPercentile * annualRange
    stopPrice = if isLong
        entryPrice - priceDistance
    else
        entryPrice + priceDistance
    stopPrice

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATE VARIABLES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Track SL / TP
var float slLevel = na
var float tpLevel = na

// Pre-calculate ATR for SL/TP
atrValue = ta.atr(atrLen)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ALERT FUNCTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Create formatted alert message with RR ratio
f_create_alert_message(string direction, float entryPrice, float stopLoss, float takeProfit) =>
    directionText = direction == "long" ? "ğŸŸ¢ BUY" : "ğŸ”´ SELL"
    
    // Calculate Risk-to-Reward ratio
    riskDistance = math.abs(entryPrice - stopLoss)
    rewardDistance = math.abs(takeProfit - entryPrice)
    rrRatio = riskDistance > 0 ? rewardDistance / riskDistance : 0
    
    alertMessage = 
     directionText + " SIGNAL\n" +
     "Symbol: " + syminfo.ticker + "\n" +
     "Entry Price: " + str.tostring(entryPrice, "#.#####") + "\n" +
     "Stop Loss: " + str.tostring(stopLoss, "#.#####") + "\n" +
     "Take Profit: " + str.tostring(takeProfit, "#.#####") + "\n" +
     "RR Ratio: 1:" + str.tostring(rrRatio, "#.##") + "\n" +
     "Time: " + str.format_time(time, "dd/MM/yyyy HH:mm", syminfo.timezone)
    alertMessage

// Check if current time is within trading hours
f_in_trading_hours() =>
    if not useTimeFilter
        true
    else
        // Takes the bar's built-in UTC 'time' and converts to defined timezone
        current_hour = hour(time, timezone_manual)
        current_minute = minute(time, timezone_manual)
        
        // Convert times to minutes for easier comparison
        start_time_minutes = start_hour * 60 + start_minute
        end_time_minutes = end_hour * 60 + end_minute
        current_time_minutes = current_hour * 60 + current_minute
        
        if start_time_minutes <= end_time_minutes
            // Normal session (e.g., 8:30 - 20:30)
            current_time_minutes >= start_time_minutes and current_time_minutes < end_time_minutes
        else    
            // Overnight session (e.g., 22:30 - 06:30)
            current_time_minutes >= start_time_minutes or current_time_minutes < end_time_minutes

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PERCENTILE-BASED RISK VALIDATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

f_validate_percentile_risk(float entryPrice, float atrStopPrice, bool isLong) =>
    // REMOVED 'var' declarations - these should be fresh for each trade evaluation
    bool canTrade = false
    float finalSL = atrStopPrice
    float finalTP = na
    string comment = ""    
    
    // Calculate ATR stop distance as percentile of annual range
    stopDistance = math.abs(entryPrice - atrStopPrice)
    atrStopPercentile = f_normalize_distance(stopDistance, annualRange)
    
    // Calculate proposed TP based on ATR and multiplier
    tpDistance = atrValue * tpMult
    proposedTP = isLong ? entryPrice + tpDistance : entryPrice - tpDistance
    
    // Check if maxPercentile feature is disabled (1.0 = 100% of annual range)
    riskDisabled = maxPercentile >= 1.0
    
    if riskDisabled or atrStopPercentile <= maxPercentile
        // ATR stop is within percentile risk limit OR feature is disabled
        canTrade := true
        finalSL := atrStopPrice
        finalTP := proposedTP        
        comment := "SL: " + str.tostring(math.round(atrStopPercentile * 10000) / 100, "#.##") + "% of annual range"
    
    else if allowTradeOnLimit
        // ATR stop exceeds limit - adjust SL to max percentile
        canTrade := true
        finalSL := f_percentile_to_price(entryPrice, maxPercentile, isLong)
        
        // Maintain risk/reward ratio using the adjusted stop
        adjustedSlDistance = math.abs(entryPrice - finalSL)
        adjustedTpDistance = adjustedSlDistance * (tpMult / slMult)
        finalTP := isLong ? entryPrice + adjustedTpDistance : entryPrice - adjustedTpDistance
        
        comment := "âš ï¸ SL Adjusted: " + str.tostring(math.round(maxPercentile * 10000) / 100, "#.##") + 
                   "% (was " + str.tostring(math.round(atrStopPercentile * 10000) / 100, "#.##") + "%)"
    
    else
        // ATR stop exceeds limit and trade adjustment not allowed - REFUSE TRADE
        canTrade := false
        comment := "âŒ Risk Too High: " + str.tostring(math.round(atrStopPercentile * 10000) / 100, "#.##") + 
                   "% > " + str.tostring(math.round(maxPercentile * 10000) / 100, "#.##") + "%"
    
    [canTrade, finalSL, finalTP, comment]
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TRADE EXECUTION LOGIC
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Only execute trades within trading hours
realTradesAllowed = f_in_trading_hours()

// Handle opposite signal closes when enabled
if allowOppositeClose and realTradesAllowed
    // Close long position on short signal
    if strategy.position_size > 0 and shortCondition
        strategy.close("Long", comment="Opposite Signal")
    
    // Close short position on long signal
    if strategy.position_size < 0 and longCondition
        strategy.close("Short", comment="Opposite Signal")

// Determine if we can enter new position
// When opposite close is enabled: enter on signal regardless of position (close handled above)
// When disabled: only enter when flat
canEnterLong = longCondition and realTradesAllowed and (allowOppositeClose or strategy.position_size == 0)
canEnterShort = shortCondition and realTradesAllowed and (allowOppositeClose or strategy.position_size == 0)

// Long trade execution
if canEnterLong
    // Calculate ATR-based stop
    slDistance = atrValue * slMult
    proposedSL = close - slDistance
    
    // Validate against max percentile risk
    [canTrade, finalSL, finalTP, comment] = f_validate_percentile_risk(close, proposedSL, true)    
    
    if canTrade
        alertMessage = f_create_alert_message("long", close, finalSL, finalTP)
        alert(alertMessage, alert.freq_once_per_bar)        
        
        // Enter with fixed position size (from strategy defaults: 5% of equity)
        strategy.entry("Long", strategy.long, comment = comment)
        
        if useSL
            slLevel := finalSL
            tpLevel := finalTP
            strategy.exit("Exit Long", "Long", stop=slLevel, limit=tpLevel, comment="TP/SL Hit")

// Short trade execution
if canEnterShort
    // Calculate ATR-based stop
    slDistance = atrValue * slMult
    proposedSL = close + slDistance
    
    // Validate against max percentile risk
    [canTrade, finalSL, finalTP, comment] = f_validate_percentile_risk(close, proposedSL, false)    
    
    if canTrade
        alertMessage = f_create_alert_message("short", close, finalSL, finalTP)
        alert(alertMessage, alert.freq_once_per_bar)        
        
        // Enter with fixed position size (from strategy defaults: 5% of equity)
        strategy.entry("Short", strategy.short, comment = comment)
        
        if useSL
            slLevel := finalSL
            tpLevel := finalTP
            strategy.exit("Exit Short", "Short", stop=slLevel, limit=tpLevel, comment="TP/SL Hit")
// =============================================== END OF: TRADING MANAGER BLOCK ===============================================

// =============================================== VISULIATION & DASHBOARD SETTINGS BLOCK ===============================================
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VISUALIZATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Only show SL/TP for current position's direction
// Reset levels if position direction changed (handles opposite close scenario)
var int lastPositionDirection = 0  // 1 = long, -1 = short, 0 = flat

currentDirection = strategy.position_size > 0 ? 1 : strategy.position_size < 0 ? -1 : 0

// Reset SL/TP if position direction changed (indicates opposite close occurred)
if currentDirection != lastPositionDirection
    slLevel := na
    tpLevel := na

lastPositionDirection := currentDirection

// Plot SL/TP lines when enabled and levels are valid
plot(useSL and strategy.position_size > 0 and not na(slLevel) ? slLevel : na, 
     "Long SL", color=color.red, style=plot.style_circles, linewidth=2)
plot(useSL and strategy.position_size > 0 and not na(tpLevel) ? tpLevel : na, 
     "Long TP", color=color.green, style=plot.style_circles, linewidth=2)
plot(useSL and strategy.position_size < 0 and not na(slLevel) ? slLevel : na, 
     "Short SL", color=color.red, style=plot.style_circles, linewidth=2)
plot(useSL and strategy.position_size < 0 and not na(tpLevel) ? tpLevel : na, 
     "Short TP", color=color.green, style=plot.style_circles, linewidth=2)

// Plot Annual Range reference levels (visual aid)
plot(annualHigh, "Annual High", color=color.blue, style=plot.style_circles, linewidth=1, display=display.none)
plot(annualLow, "Annual Low", color=color.blue, style=plot.style_circles, linewidth=1, display=display.none)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PERFORMANCE DASHBOARD
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DASHBOARD INPUT PARAMETERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Dashboard Groups Definitions
gDash_title = "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ğŸ§®Performance DashboardğŸ§®â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
gDash_tooltip = "ğŸ‘‰ Comprehensive performance tracking and statistics\n" +
               "ğŸ”¹ Real-time trade metrics and performance analytics\n" +
               "ğŸ”¹ Separate tracking for long and short trades\n" +
               "ğŸ”¹ Filter and trading parameter summaries\n\n" +
               "ğŸ‘‰ Features:\n" +
               "â–ª Win rates and profit factors for both directions\n" +
               "â–ª Average trade duration in bars\n" +
               "â–ª Equity curve and drawdown monitoring\n" +
               "â–ª Current filter settings overview\n" +
               "â–ª Annual range and risk percentile information"

// Dashboard Settings
dashboardMode = input.string("Short", "ğŸ§® Dashboard Mode", 
     options=["Off", "Short", "Full"], 
     group=gDash_title, inline="dash1", tooltip=gDash_tooltip)
dashboardPosition = input.string("Bottom Right", "ğŸ“ Dashboard Position", 
     options=["Top Left", "Top Right", "Bottom Left", "Bottom Right"], 
     group=gDash_title, inline="dash1",
     tooltip="Choose where the performance dashboard appears on your chart")

// Get dashboard position from input
getDashboardPosition() =>
    switch dashboardPosition
        "Top Left" => position.top_left
        "Top Right" => position.top_right
        "Bottom Left" => position.bottom_left
        => position.bottom_right

// Signal counting
var int totalLongSignals = 0
var int totalShortSignals = 0

if longCondition
    totalLongSignals += 1

if shortCondition
    totalShortSignals += 1

// Calculate built-in metrics
totalSignals = totalLongSignals + totalShortSignals
winRate = strategy.closedtrades > 0 ? (strategy.wintrades / strategy.closedtrades) * 100 : 0
profitFactor = strategy.grossloss > 0 ? strategy.grossprofit / strategy.grossloss : strategy.grossprofit > 0 ? 999 : 0
avgTrade = strategy.closedtrades > 0 ? strategy.netprofit / strategy.closedtrades : 0
maxDD = strategy.max_drawdown
maxDDPercent = strategy.initial_capital > 0 ? (maxDD / strategy.initial_capital) * 100 : 0
totalReturn = strategy.initial_capital > 0 ? ((strategy.equity - strategy.initial_capital) / strategy.initial_capital) * 100 : 0

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LONG/SHORT PERFORMANCE METRICS CALCULATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var longTrades = 0
var shortTrades = 0
var longWins = 0
var shortWins = 0
var float longGrossProfit = 0.0
var float longGrossLoss = 0.0
var float shortGrossProfit = 0.0
var float shortGrossLoss = 0.0

// Track the last processed trade count to avoid double counting
var int lastTradeCount = 0

// This logic runs on every bar, but only processes when new trades are closed
if strategy.closedtrades > lastTradeCount
    // Process each new trade that hasn't been counted yet
    for i = lastTradeCount to strategy.closedtrades - 1
        tradeProfit = strategy.closedtrades.profit(i)
        tradeSize = strategy.closedtrades.size(i)
        
        // positive size = long, negative size = short
        if tradeSize > 0
            // This was a long trade
            longTrades += 1
            if tradeProfit > 0
                longWins += 1
                longGrossProfit += tradeProfit
            else
                longGrossLoss += math.abs(tradeProfit)
                
        else if tradeSize < 0
            // This was a short trade  
            shortTrades += 1
            if tradeProfit > 0
                shortWins += 1
                shortGrossProfit += tradeProfit
            else
                shortGrossLoss += math.abs(tradeProfit)
    
    // Update the counter to current trade count
    lastTradeCount := strategy.closedtrades

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TRADE DURATION TRACKING VARIABLES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Variables to track trade durations
var int[] longTradeBars = array.new_int()
var int[] shortTradeBars = array.new_int()
var int[] longWinTradeBars = array.new_int()
var int[] shortWinTradeBars = array.new_int()
var int[] longLossTradeBars = array.new_int()
var int[] shortLossTradeBars = array.new_int()

var int currentTradeEntryBar = na
var string currentTradeDirection = ""

// Track when new trades open and close
tradeJustOpened = strategy.position_size[1] == 0 and strategy.position_size != 0
tradeJustClosed = strategy.position_size[1] != 0 and strategy.position_size == 0

// Record entry bar when trade opens
if tradeJustOpened
    currentTradeEntryBar := bar_index
    currentTradeDirection := strategy.position_size > 0 ? "long" : "short"

// Record trade duration when trade closes
if tradeJustClosed and not na(currentTradeEntryBar)
    tradeDuration = bar_index - currentTradeEntryBar
    tradeProfit = strategy.closedtrades.profit(strategy.closedtrades - 1)
    
    if currentTradeDirection == "long"
        array.push(longTradeBars, tradeDuration)
        if tradeProfit > 0
            array.push(longWinTradeBars, tradeDuration)
        else
            array.push(longLossTradeBars, tradeDuration)
    else
        array.push(shortTradeBars, tradeDuration)
        if tradeProfit > 0
            array.push(shortWinTradeBars, tradeDuration)
        else
            array.push(shortLossTradeBars, tradeDuration)

// Calculate average durations
avgLongBars = array.size(longTradeBars) > 0 ? array.avg(longTradeBars) : 0
avgShortBars = array.size(shortTradeBars) > 0 ? array.avg(shortTradeBars) : 0
avgTotalBars = (array.size(longTradeBars) + array.size(shortTradeBars)) > 0 ? 
     (array.sum(longTradeBars) + array.sum(shortTradeBars)) / (array.size(longTradeBars) + array.size(shortTradeBars)) : 0

avgLongWinBars = array.size(longWinTradeBars) > 0 ? array.avg(longWinTradeBars) : 0
avgShortWinBars = array.size(shortWinTradeBars) > 0 ? array.avg(shortWinTradeBars) : 0
avgTotalWinBars = (array.size(longWinTradeBars) + array.size(shortWinTradeBars)) > 0 ? 
     (array.sum(longWinTradeBars) + array.sum(shortWinTradeBars)) / (array.size(longWinTradeBars) + array.size(shortWinTradeBars)) : 0

avgLongLossBars = array.size(longLossTradeBars) > 0 ? array.avg(longLossTradeBars) : 0
avgShortLossBars = array.size(shortLossTradeBars) > 0 ? array.avg(shortLossTradeBars) : 0
avgTotalLossBars = (array.size(longLossTradeBars) + array.size(shortLossTradeBars)) > 0 ? 
     (array.sum(longLossTradeBars) + array.sum(shortLossTradeBars)) / (array.size(longLossTradeBars) + array.size(shortLossTradeBars)) : 0

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// OPPOSITE SIGNAL CLOSE DETECTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var int longOppositeCloses = 0
var int shortOppositeCloses = 0
var int totalOppositeCloses = 0

// Detect opposite signal closes
if allowOppositeClose and realTradesAllowed
    if strategy.position_size > 0 and shortCondition
        longOppositeCloses += 1
        totalOppositeCloses += 1
    
    if strategy.position_size < 0 and longCondition
        shortOppositeCloses += 1
        totalOppositeCloses += 1

// Calculate percentages
longOppositePercent = longTrades > 0 ? (longOppositeCloses / longTrades) * 100 : 0
shortOppositePercent = shortTrades > 0 ? (shortOppositeCloses / shortTrades) * 100 : 0
totalOppositePercent = strategy.closedtrades > 0 ? (totalOppositeCloses / strategy.closedtrades) * 100 : 0

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PERFORMANCE DASHBOARD TABLE HELPER FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Helper function for creating header cells to reduce repetition
fillHeaderCell(tbl, col, textfill) =>
    table.cell(tbl, col, 0, textfill, bgcolor=color.new(color.blue, 70),
         text_color=color.white, text_size=size.normal, text_halign=text.align_center, text_formatting=text.format_bold)

// Helper function for creating data cells
fillDataCell(tbl, col, row, textfill, txt_color) =>
    table.cell(tbl, col, row, textfill, text_color=txt_color, text_halign=text.align_center, text_size=size.normal)

// Helper function for merged cells
fillMergedCell(tbl, row, title, value, txt_color) =>
    table.cell(tbl, 0, row, title, text_color=color.white, text_halign=text.align_center, text_size=size.normal)
    table.merge_cells(tbl, 1, row, 3, row)
    table.cell(tbl, 1, row, value, text_color=txt_color, text_halign=text.align_center, text_size=size.normal)

// Helper function to determine color based on profit factor value
pfColor(pf) => pf > 2 ? color.green : pf > 1.5 ? color.yellow : pf > 1 ? color.orange : color.red

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INPUT PARAMETER SETTINGS HELPER FUNCTIONs
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Define a visual separator (â€¢ = bullet point, | = pipe, â€º = arrow, â–« = small square)
vis_sep = "â€¢"

// Function to get source information
f_get_sources() =>
    string sourceText = ""
    string customSources = ""
    
    if longSrc1 != close
        customSources += "PrimğŸŸ¢"
    if shortSrc1 != close
        customSources += "PrimğŸ”´"
    if longSrc2 != close
        customSources += "SecğŸŸ¢" 
    if shortSrc2 != close
        customSources += "SecğŸ”´"
    
    if customSources != ""
        sourceText := str.tostring(customSources)
    else
        sourceText := "external source missing"
    
    sourceText

f_get_filter_settings() =>
    string filterText = ""
    int filterCount = 0
    string currentLine = ""
    
    // HTF Settings
    if htfTimeframe != ""
        filterText += "HTF:" + htfTimeframe + "\n"
    
    // Array to collect all active filters
    array<string> activeFilters = array.new<string>()
    
    // MACD Filter
    if useMACD
        modeAbbr = macdMode == "Classic" ? "C" : macdMode == "Histogram Slope" ? "S" : "B"
        array.push(activeFilters, "MACD:" + modeAbbr + str.tostring(macdFastLen) + "/" + str.tostring(macdSlowLen) + "/" + str.tostring(macdSignalLen) + "/" + str.tostring(macdSlopeLen))
    
    // MA Filter
    if useMA
        maTypeAbbr = maType == "SMA" ? "S" : maType == "EMA" ? "E" : maType == "WMA" ? "W" : "H"
        array.push(activeFilters, maTypeAbbr + "MA:" + str.tostring(maLen) + "/" + str.tostring(maSlopeLen))
    
    // VWAP Filter
    if useVWAP
        array.push(activeFilters, "VWAP:" + str.tostring(vwapBuffer, "#.##"))
    
    // Supertrend Filter
    if useSUPT
        array.push(activeFilters, "SupT:" + str.tostring(suptAtrLen) + "/" + str.tostring(suptFactor, "#.#"))
    
    // Choppiness Filter
    if useChop
        array.push(activeFilters, "Chop:" + str.tostring(ciLen) + "/" + str.tostring(chopThr, "#.#"))
    
    // ADX Filter
    if useADX
        array.push(activeFilters, "ADX:" + str.tostring(adxLen) + "/" + str.tostring(adxThr, "#.#") + "/" + str.tostring(diLen))
    
    // ROC Filter
    if useROC
        array.push(activeFilters, "ROC:" + str.tostring(rocLen) + "/" + str.tostring(rocThreshold, "#.##"))
    
    // Volume Filter
    if useVol
        array.push(activeFilters, "Vol:" + str.tostring(volMaLen) + "/" + str.tostring(atrLenVol))
       
    // Bollinger Bands Width Filter
    if useBBW
        array.push(activeFilters, "BB:" + str.tostring(bbLen) + "/" + str.tostring(bbwMaLen) + "/" + str.tostring(bbwFilterMult, "#.##"))
    
    // Keltner Channels Filter
    if useKC
        array.push(activeFilters, "KC:" + str.tostring(kcLen) + "/" + str.tostring(kcMult, "#.#") + "/" + str.tostring(kcATRlen))
    
    // RSI Filter
    if useRSI
        array.push(activeFilters, "RSI:" + str.tostring(rsiLen) + "/" + str.tostring(rsiOverbought) + "/" + str.tostring(rsiOversold))
    
    // DPO Filter
    if useDPO
        array.push(activeFilters, "DPO:" + str.tostring(dpoLen) + "/" + str.tostring(dpoSmooth) + "/" + str.tostring(dpoThresh, "#.##"))
    
    // CCI Filter
    if useCCI
        array.push(activeFilters, "CCI:" + str.tostring(cciLen) + "/" + str.tostring(cciOverbought) + "/" + str.tostring(cciOversold))
    
    // Pivot Structure Filter
    if useStructurePivot
        array.push(activeFilters, "Piv:" + str.tostring(zzPercent, "#.##"))
    
    // Local Angle Filter
    if useStructureAngle
        array.push(activeFilters, "LA:" + str.tostring(angleLen) + "/" + str.tostring(minAngle, "#.##"))
    
    // Check if we have any filters
    if array.size(activeFilters) > 0
        // Process filters in pairs
        for i = 0 to array.size(activeFilters) - 1
            string filterStr = array.get(activeFilters, i)
            
            if filterCount % 2 == 0
                // First filter in pair
                currentLine := filterStr
            else
                // Second filter in pair - add separator and line break
                currentLine += vis_sep + filterStr
                filterText += currentLine + "\n"
                currentLine := ""
            
            filterCount += 1
        
        // Add any remaining filter on the last line
        if currentLine != ""
            filterText += currentLine
    else
        // No filters active
        if filterText == ""  // No HTF either
            filterText := "No Filters"
        // If we have HTF but no filters, filterText already contains HTF line
    
    // Remove trailing newline and check if empty
    filterText := str.replace_all(filterText, "\n$", "")
    filterText := str.trim(filterText)
    if filterText == ""
        filterText := "No Filters"
    
    filterText

// Function to generate trading input parameters string
f_get_trading_params() =>
    string paramsText = ""
    
    // Time Filter
    if useTimeFilter
        paramsText += "Time:" + str.tostring(start_hour) + ":" + str.tostring(start_minute, "00") + "-" + str.tostring(end_hour) + ":" + str.tostring(end_minute, "00") + vis_sep
    else
        paramsText += "24/7" + vis_sep
    
    // Close on opposite string
    paramsText += "Opposite Close:" + (allowOppositeClose ? "Y" : "N") + "\n"
    

    // SL/TP Parameters
    if useSL
        // ATR Length
        paramsText += "ATR:" + str.tostring(atrLen) + vis_sep
        paramsText += "SL:" + str.tostring(slMult, "#.#") + " TP:" + str.tostring(tpMult, "#.#") + "\n"
    else
        paramsText += "NoSL/TP"
           
    // Risk Management - max percentile
    if maxPercentile <= 1
        paramsText += "Risk:" + str.tostring(math.round(maxPercentile * 100, 2)) + "%" + vis_sep
    else
        paramsText += "Risk:Unltd" + vis_sep
    
    // Limit Mode
    paramsText += "Limit:" + (allowTradeOnLimit ? "Y" : "N")
    
    // Remove trailing separator if exists
    paramsText := str.replace_all(paramsText, vis_sep + "$", "")
    
    paramsText

// Function to get annual range information for Full mode
f_get_annual_range_info() =>
    string rangeText = ""
    
    if not na(annualRange) and annualRange > 0
        rangeText := "Annual Range: " + str.tostring(math.round(annualRange, 4)) + " (" + 
                     str.tostring(math.round(annualLow, 4)) + " - " + 
                     str.tostring(math.round(annualHigh, 4)) + ")"
    else
        rangeText := "Annual Range: Calculating..."
    
    rangeText

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PERFORMANCE DASHBOARD TABLE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var table performanceTable = na

if dashboardMode != "Off" and (barstate.islast or barstate.isconfirmed and barstate.islastconfirmedhistory)
    if not na(performanceTable)
        table.delete(performanceTable)
    // Calculate metrics - FIXED FOR AVG PROFIT/TRADE
    longWinRate = longTrades > 0 ? (longWins / longTrades) * 100 : 0
    shortWinRate = shortTrades > 0 ? (shortWins / shortTrades) * 100 : 0
    
    longNetProfit = longGrossProfit - longGrossLoss
    shortNetProfit = shortGrossProfit - shortGrossLoss
    
    longProfitFactor = longGrossLoss > 0 ? longGrossProfit / longGrossLoss : longGrossProfit > 0 ? 999 : 0
    shortProfitFactor = shortGrossLoss > 0 ? shortGrossProfit / shortGrossLoss : shortGrossProfit > 0 ? 999 : 0
    
    // NEW: Calculate the additional metrics
    totalLossTrades = strategy.losstrades
    
    // FIXED: Avg Profit/Trade = Gross Profit / Total Winning Trades
    avgTrade = strategy.closedtrades > 0 ? strategy.grossprofit / strategy.wintrades : 0
    
    // For loss calculations
    avgLossPerTrade = totalLossTrades > 0 ? math.abs(strategy.grossloss) / totalLossTrades : 0
    avgTradeFactor = avgLossPerTrade != 0 ? math.abs(avgTrade) / avgLossPerTrade : avgTrade > 0 ? 999 : 0

    // Long/Short specific calculations - FIXED
    longLossTrades = longTrades - longWins
    shortLossTrades = shortTrades - shortWins

    avgLongLoss = longLossTrades > 0 ? math.abs(longGrossLoss) / longLossTrades : 0
    avgShortLoss = shortLossTrades > 0 ? math.abs(shortGrossLoss) / shortLossTrades : 0
    
    // FIXED: Use gross profit for average profit calculations
    avgLongTrade = longTrades > 0 ? longGrossProfit / longWins : 0
    avgShortTrade = shortTrades > 0 ? shortGrossProfit / shortWins : 0
    
    avgLongTradeFactor = avgLongLoss != 0 ? math.abs(avgLongTrade) / avgLongLoss : avgLongTrade > 0 ? 999 : 0
    avgShortTradeFactor = avgShortLoss != 0 ? math.abs(avgShortTrade) / avgShortLoss : avgShortTrade > 0 ? 999 : 0
    
    // Get settings texts
    sourcesText = f_get_sources()
    filterSettingsText = f_get_filter_settings()
    tradingParamsText = f_get_trading_params()
    annualRangeText = f_get_annual_range_info()
    
    // Determine table size based on mode - UPDATED ROW COUNTS
    tableRows = dashboardMode == "Full" ? 25 : 15  // Full mode: 25 rows (0-24), Short mode: 15 rows (0-14)
    
    performanceTable := table.new(getDashboardPosition(), 4, tableRows,
         bgcolor=color.new(color.black, 85),
         border_width=1,
         border_color=color.gray)
    
    // --- TABLE CONTENT ---
    // Title row (row 0)
    fillHeaderCell(performanceTable, 0, "PERFORMANCE")
    fillHeaderCell(performanceTable, 1, "LONG")
    fillHeaderCell(performanceTable, 2, "SHORT")
    fillHeaderCell(performanceTable, 3, "TOTAL")
    
    // Signals Section (row 1)
    fillDataCell(performanceTable, 0, 1, "Signals", color.white)
    fillDataCell(performanceTable, 1, 1, str.tostring(totalLongSignals), color.white)
    fillDataCell(performanceTable, 2, 1, str.tostring(totalShortSignals), color.white)
    fillDataCell(performanceTable, 3, 1, str.tostring(totalSignals), color.yellow)
    
    // Trades Section (row 2)
    fillDataCell(performanceTable, 0, 2, "Trades", color.white)
    fillDataCell(performanceTable, 1, 2, str.tostring(longTrades), color.white)
    fillDataCell(performanceTable, 2, 2, str.tostring(shortTrades), color.white)
    fillDataCell(performanceTable, 3, 2, str.tostring(strategy.closedtrades), color.white)
    
    // Winning Trades (row 3)
    fillDataCell(performanceTable, 0, 3, "Winning Trades", color.white)
    fillDataCell(performanceTable, 1, 3, str.tostring(longWins), color.green)
    fillDataCell(performanceTable, 2, 3, str.tostring(shortWins), color.green)
    fillDataCell(performanceTable, 3, 3, str.tostring(strategy.wintrades), color.green)
    
    // Losing Trades (row 4)
    fillDataCell(performanceTable, 0, 4, "Losing Trades", color.white)
    fillDataCell(performanceTable, 1, 4, str.tostring(longTrades - longWins), color.red)
    fillDataCell(performanceTable, 2, 4, str.tostring(shortTrades - shortWins), color.red)
    fillDataCell(performanceTable, 3, 4, str.tostring(strategy.losstrades), color.red)

    // Win Rate % (row 5)
    fillDataCell(performanceTable, 0, 5, "Win Rate %", color.white)
    fillDataCell(performanceTable, 1, 5, str.tostring(longWinRate, "#.##") + "%", longWinRate >= 50 ? color.green : color.orange)
    fillDataCell(performanceTable, 2, 5, str.tostring(shortWinRate, "#.##") + "%", shortWinRate >= 50 ? color.green : color.orange)
    fillDataCell(performanceTable, 3, 5, str.tostring(winRate, "#.##") + "%", winRate >= 50 ? color.green : color.orange)
    
    // Opposite Signal Closes % (row 6)
    fillDataCell(performanceTable, 0, 6, "Opposite Closes %", color.white)
    fillDataCell(performanceTable, 1, 6, str.tostring(longOppositePercent, "#.##") + "%", color.purple)
    fillDataCell(performanceTable, 2, 6, str.tostring(shortOppositePercent, "#.##") + "%", color.purple)
    fillDataCell(performanceTable, 3, 6, str.tostring(totalOppositePercent, "#.##") + "%", color.purple)
    
    // Avg Bars in Trades (row 7)
    fillDataCell(performanceTable, 0, 7, "Avg Bars/Trade", color.white)
    fillDataCell(performanceTable, 1, 7, str.tostring(math.round(avgLongBars), "#"), color.blue)
    fillDataCell(performanceTable, 2, 7, str.tostring(math.round(avgShortBars), "#"), color.blue)
    fillDataCell(performanceTable, 3, 7, str.tostring(math.round(avgTotalBars), "#"), color.blue)
    
    // Avg Bars in Winning Trades (row 8)
    fillDataCell(performanceTable, 0, 8, "Avg Bars/Win", color.white)
    fillDataCell(performanceTable, 1, 8, str.tostring(math.round(avgLongWinBars), "#"), color.green)
    fillDataCell(performanceTable, 2, 8, str.tostring(math.round(avgShortWinBars), "#"), color.green)
    fillDataCell(performanceTable, 3, 8, str.tostring(math.round(avgTotalWinBars), "#"), color.green)
    
    // Avg Bars in Losing Trades (row 9)
    fillDataCell(performanceTable, 0, 9, "Avg Bars/Loss", color.white)
    fillDataCell(performanceTable, 1, 9, str.tostring(math.round(avgLongLossBars), "#"), color.red)
    fillDataCell(performanceTable, 2, 9, str.tostring(math.round(avgShortLossBars), "#"), color.red)
    fillDataCell(performanceTable, 3, 9, str.tostring(math.round(avgTotalLossBars), "#"), color.red)
    
    // Profit Factor (row 10)
    fillDataCell(performanceTable, 0, 10, "Profit Factor", color.white)
    fillDataCell(performanceTable, 1, 10, str.tostring(math.min(longProfitFactor, 999.9), "#.###"), pfColor(longProfitFactor))
    fillDataCell(performanceTable, 2, 10, str.tostring(math.min(shortProfitFactor, 999.9), "#.###"), pfColor(shortProfitFactor))
    fillDataCell(performanceTable, 3, 10, str.tostring(math.min(profitFactor, 999.9), "#.###"), pfColor(profitFactor))
    
    // Only show additional rows in Full mode
    if dashboardMode == "Full"
        // Gross Profit (row 11)
        fillDataCell(performanceTable, 0, 11, "Gross Profit", color.white)
        fillDataCell(performanceTable, 1, 11, "$" + str.tostring(longGrossProfit, "#.##"), color.green)
        fillDataCell(performanceTable, 2, 11, "$" + str.tostring(shortGrossProfit, "#.##"), color.green)
        fillDataCell(performanceTable, 3, 11, "$" + str.tostring(strategy.grossprofit, "#.##"), color.green)
        
        // Gross Loss (row 12)
        fillDataCell(performanceTable, 0, 12, "Gross Loss", color.white)
        fillDataCell(performanceTable, 1, 12, "$" + str.tostring(longGrossLoss, "#.##"), color.red)
        fillDataCell(performanceTable, 2, 12, "$" + str.tostring(shortGrossLoss, "#.##"), color.red)
        fillDataCell(performanceTable, 3, 12, "$" + str.tostring(strategy.grossloss, "#.##"), color.red)
        
        // Net Profit (row 13)
        fillDataCell(performanceTable, 0, 13, "Net Profit", color.white)
        fillDataCell(performanceTable, 1, 13, "$" + str.tostring(longNetProfit, "#.##"), longNetProfit > 0 ? color.green : color.red)
        fillDataCell(performanceTable, 2, 13, "$" + str.tostring(shortNetProfit, "#.##"), shortNetProfit > 0 ? color.green : color.red)
        fillDataCell(performanceTable, 3, 13, "$" + str.tostring(strategy.netprofit, "#.##"), strategy.netprofit > 0 ? color.green : color.red)
        
        // Avg Profit per Trade (row 14)
        fillDataCell(performanceTable, 0, 14, "Avg Profit/Trade", color.white)
        fillDataCell(performanceTable, 1, 14, "$" + str.tostring(avgLongTrade, "#.##"), avgLongTrade > 0 ? color.green : color.red)
        fillDataCell(performanceTable, 2, 14, "$" + str.tostring(avgShortTrade, "#.##"), avgShortTrade > 0 ? color.green : color.red)
        fillDataCell(performanceTable, 3, 14, "$" + str.tostring(avgTrade, "#.##"), avgTrade > 0 ? color.green : color.red)
        
        // NEW: Avg Loss per Trade (row 15)
        fillDataCell(performanceTable, 0, 15, "Avg Loss/Trade", color.white)
        fillDataCell(performanceTable, 1, 15, "$" + str.tostring(avgLongLoss, "#.##"), color.red)
        fillDataCell(performanceTable, 2, 15, "$" + str.tostring(avgShortLoss, "#.##"), color.red)
        fillDataCell(performanceTable, 3, 15, "$" + str.tostring(avgLossPerTrade, "#.##"), color.red)
        
        // NEW: Avg Trade Factor (row 16)
        fillDataCell(performanceTable, 0, 16, "Avg Trade Factor", color.white)
        fillDataCell(performanceTable, 1, 16, str.tostring(math.min(avgLongTradeFactor, 999.9), "#.###"), pfColor(avgLongTradeFactor))
        fillDataCell(performanceTable, 2, 16, str.tostring(math.min(avgShortTradeFactor, 999.9), "#.###"), pfColor(avgShortTradeFactor))
        fillDataCell(performanceTable, 3, 16, str.tostring(math.min(avgTradeFactor, 999.9), "#.###"), pfColor(avgTradeFactor))
        
        // Total Return (row 17)
        fillMergedCell(performanceTable, 17, "Total Return", str.tostring(totalReturn, "#.##") + "%", totalReturn > 0 ? color.green : color.red)
            
        // Max Drawdown (row 18)
        ddColor = maxDDPercent > 20 ? color.red : maxDDPercent > 10 ? color.orange : color.yellow
        fillMergedCell(performanceTable, 18, "Max Drawdown", "$" + str.tostring(maxDD, "#.##") + " (" + str.tostring(maxDDPercent, "#.##") + "%)", ddColor)
        
        // Equity (row 19)
        fillMergedCell(performanceTable, 19, "Equity", "$" + str.tostring(strategy.equity, "#.##"), color.white)
        
        // Initial Capital (row 20)
        fillMergedCell(performanceTable, 20, "Initial Capital", "$" + str.tostring(strategy.initial_capital, "#.##"), color.white)
        
        // Annual Range Information (row 21)
        table.cell(performanceTable, 0, 21, "Annual Range", text_color=color.white, text_halign=text.align_center, text_size=size.small)
        table.merge_cells(performanceTable, 1, 21, 3, 21)
        table.cell(performanceTable, 1, 21, annualRangeText, text_color=color.fuchsia, text_halign=text.align_center, text_size=size.small)
        
        // Sources (Full mode - row 22)
        table.cell(performanceTable, 0, 22, "Sources", text_color=color.white, text_halign=text.align_center, text_size=size.small)
        table.merge_cells(performanceTable, 1, 22, 3, 22)
        table.cell(performanceTable, 1, 22, sourcesText, text_color=color.orange, text_halign=text.align_center, text_size=size.small)
        
        // Filters (Full mode - row 23)
        table.cell(performanceTable, 0, 23, "Filters", text_color=color.white, text_halign=text.align_center, text_size=size.small)
        table.merge_cells(performanceTable, 1, 23, 3, 23)
        table.cell(performanceTable, 1, 23, filterSettingsText, text_color=color.lime, text_halign=text.align_center, text_size=size.small)

        // Trading (Full mode - row 24)
        table.cell(performanceTable, 0, 24, "Trading", text_color=color.white, text_halign=text.align_center, text_size=size.small)
        table.merge_cells(performanceTable, 1, 24, 3, 24)
        table.cell(performanceTable, 1, 24, tradingParamsText, text_color=color.yellow, text_halign=text.align_center, text_size=size.small)
    else
        // Short mode - NEW: Avg Trade Factor (row 11)
        fillDataCell(performanceTable, 0, 11, "Avg Trade Factor", color.white)
        fillDataCell(performanceTable, 1, 11, str.tostring(math.min(avgLongTradeFactor, 999.9), "#.###"), pfColor(avgLongTradeFactor))
        fillDataCell(performanceTable, 2, 11, str.tostring(math.min(avgShortTradeFactor, 999.9), "#.###"), pfColor(avgShortTradeFactor))
        fillDataCell(performanceTable, 3, 11, str.tostring(math.min(avgTradeFactor, 999.9), "#.###"), pfColor(avgTradeFactor))
        
        // Sources, Filters, Trading (rows 12-14)
        table.cell(performanceTable, 0, 12, "Sources", text_color=color.white, text_halign=text.align_center, text_size=size.small)
        table.merge_cells(performanceTable, 1, 12, 3, 12)
        table.cell(performanceTable, 1, 12, sourcesText, text_color=color.orange, text_halign=text.align_center, text_size=size.small)
        
        table.cell(performanceTable, 0, 13, "Filters", text_color=color.white, text_halign=text.align_center, text_size=size.small)
        table.merge_cells(performanceTable, 1, 13, 3, 13)
        table.cell(performanceTable, 1, 13, filterSettingsText, text_color=color.lime, text_halign=text.align_center, text_size=size.small)

        table.cell(performanceTable, 0, 14, "Trading", text_color=color.white, text_halign=text.align_center, text_size=size.small)
        table.merge_cells(performanceTable, 1, 14, 3, 14)
        table.cell(performanceTable, 1, 14, tradingParamsText, text_color=color.yellow, text_halign=text.align_center, text_size=size.small)
// =============================================== END OFF: VISULIATION & DASHBOARD SETTINGS BLOCK ===============================================
// ========================================================== END OFF: STRATEGY SCRIPT ===========================================================